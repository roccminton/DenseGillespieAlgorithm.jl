<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · DenseGillespieAlgorithm.jl</title><meta name="title" content="Examples · DenseGillespieAlgorithm.jl"/><meta property="og:title" content="Examples · DenseGillespieAlgorithm.jl"/><meta property="twitter:title" content="Examples · DenseGillespieAlgorithm.jl"/><meta name="description" content="Documentation for DenseGillespieAlgorithm.jl."/><meta property="og:description" content="Documentation for DenseGillespieAlgorithm.jl."/><meta property="twitter:description" content="Documentation for DenseGillespieAlgorithm.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="DGAPackage.html">DenseGillespieAlgorithm.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="DGAPackage.html">Home</a></li><li><a class="tocitem" href="manual.html">Manual</a></li><li class="is-active"><a class="tocitem" href="examples.html">Examples</a><ul class="internal"><li><a class="tocitem" href="#SIR-Model"><span>SIR-Model</span></a></li><li><a class="tocitem" href="#Continuous-trait-space"><span>Continuous trait space</span></a></li><li><a class="tocitem" href="#High-dimensional-model"><span>High-dimensional model</span></a></li></ul></li><li><a class="tocitem" href="perform.html">Performance Tips</a></li><li><a class="tocitem" href="index.html">Public API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="examples.html">Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="examples.html">Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/roccminton/DenseGillespieAlgorithm.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/roccminton/DenseGillespieAlgorithm.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Three illustrative examples are provided. The first is a minimal working example, designed to facilitate the initial implementation of the framework on the user&#39;s machine. The second is a slightly more advanced example, which illustrates the use of an uncountable trait space. The third is a highly complex example, which demonstrates the comprehensive versatility of the package.</p><h2 id="SIR-Model"><a class="docs-heading-anchor" href="#SIR-Model">SIR-Model</a><a id="SIR-Model-1"></a><a class="docs-heading-anchor-permalink" href="#SIR-Model" title="Permalink"></a></h2><p>The SIR model is a tree-dimensional model that is used to model infectious diseases. It is a simple model that assumes that individuals can be placed into one of three categories: susceptible, infected, or recovered. Infected individuals can infect susceptible individuals through random interactions. After becoming infected, individuals can recover and become immune. For more details, see for example <a href="https://people.wku.edu/lily.popova.zhuhadar/">here</a>.</p><p>The initial step is to implement the fundamental interaction functions. In this scenario, two events are occurring: infection and recovery. The objective is to implement these functions in a manner that modifies the population state, which is represented as a vector with three entries, one for each possible state of an individual.</p><pre><code class="language-julia hljs">using Plots
using DenseGillespieAlgorithm

# Define the reactions
function infection!(x)
    x[1] += -1
    x[2] += 1
    nothing
end

function recovery!(x)
    x[2] += -1
    x[3] += 1
    nothing
end</code></pre><p>The subsequent step is to combine the aforementioned two functions into a single execute function, which will subsequently be provided to the algorithm.</p><pre><code class="language-julia hljs">#Combine all reactions into one execute! function
function execute!(i,x,par)
    if i == 1
        infection!(x)
    elseif i == 2
        recovery!(x)
    else
        error(&quot;Unknown event number i = $i&quot;)
    end
    nothing
end</code></pre><p>Furthermore, define the rate at which the events occur, which also depends on the population state. It should be noted that a modification of an existing variable that holds the current rates is necessary. In this case, as there are two events, namely infection and recovery, the rates variable will be a vector with two entries.</p><pre><code class="language-julia hljs"># Define the reactions (reaction rates and species interactions)
function rates!(rates,x,par)
    #rate of infection
    rates[1] = par.β * x[1] * x[2]
    #rate of recovery
    rates[2] = par.γ * x[2]
    nothing
end</code></pre><p>Prior to commencing the study, it is essential to define all relevant model parameters. These include the interaction rates, the initial population state and the time horizon for the simulation. Prior to commencing the simulation, it is essential to define all relevant model parameters. These include the interaction rates, the initial population state and the time horizon for the simulation. Additionally, it is necessary to provide the algorithm with an empty population history, which will be populated with data during runtime.</p><pre><code class="language-julia hljs">#Define the model parameter 
par = (
    β = 0.000005,
    γ = 0.005
    )

# Define the initial state of the system 
x0 = [9999,1,0]

# Define the time horizon for the simulation
t = 0:2000

# Initialize population history
hist = zeros(Int,(length(t),3))</code></pre><p>At this point in the process, all the necessary components have been put in place, and the task can be handed over to the core function of the package. Once the simulation has been executed, the results are plotted.</p><pre><code class="language-julia hljs"># Run the simulation
run_gillespie!(
        t,x0,par,
        execute!,rates!,
        Vector{Float64}(undef,2),hist
        )

# Analyze or plot the result (example with a simple print)
plot(hist,label=[&quot;S&quot; &quot;I&quot; &quot;R&quot;])</code></pre><p><img src="https://roccminton.github.io/images/SIR.png" alt="SIR Plot"/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>While it is feasible to construct such straightforward examples using the DenseGillespieAlgorithm, this is not the typical application. For relatively simple models, the <a href="https://docs.sciml.ai/JumpProcesses/stable/">JumpProcess.jl</a> package offers greater flexibility and facilitates the implementation process.</p></div></div><h2 id="Continuous-trait-space"><a class="docs-heading-anchor" href="#Continuous-trait-space">Continuous trait space</a><a id="Continuous-trait-space-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-trait-space" title="Permalink"></a></h2><p>In this example, we consider an individual-based model of adaptive dynamics, wherein the trait space is a subset of the real line. It is therefore impossible to list all the types and interaction rates between them, as there are uncountably many. It is thus necessary to implement the rates and interactions in a dynamic manner. </p><p>In the context of adaptive dynamics models, individuals are characterised by a specific trait, which in this case is a real number. The mortality and fertility rates of individuals are contingent upon this trait. Moreover, competition among individuals is contingent upon the trait in question. Furthermore, at birth, with a probability of μ, the offspring undergoes a mutation and displays a distinct trait in comparison to its parents. </p><p>For further insight into the subject of adaptive dynamics models, we would direct the reader to the <a href="https://www.dropbox.com/scl/fi/8f0pdhq471unbla5dw5xh/LN_SMLS.pdf?rlkey=b0eodhvonuehueuancxeoqloz&amp;st=eqd3ffwj&amp;dl=0">lecture notes</a> by Anton Bovier.</p><p>We present a specific case study of an adaptive dynamics model, originally proposed by Dieckmann and Doebeli<sup class="footnote-reference"><a id="citeref-Dieckmann99" href="#footnote-Dieckmann99">[Dieckmann99]</a></sup>. Here the trait space is <span>$\mathcal{X} = [-1,1] \subset \mathbb{R}$</span>. The birth rate is given by <span>$b(x)=exp(-x^2/2\sigma^2_b$</span> for some <span>$\sigma_b &gt; 0$</span>. The death rate is constant <span>$d(x) = d$</span> and the competion between individuals depends only on theri distance by <span>$c(x,y)=exp(-(x-y)^2/2\sigma^2_c$</span> for some <span>$\sigma_c &gt; 0$</span>. Moreover the mutation kernel, that chooses the new trait of an offspring at birth is a Gaussian law with mean 0 and variance 0.1 conditioned to [-1,1].</p><p>The next step is to begin the implementation of this model, starting with the rates function.</p><pre><code class="language-julia hljs">#birth rate
b(x, σ) = exp(-x^2 / (2σ^2))
#death rate
d(x,d) = d
#competiton kernel
c(x, y, σ, K) = inv(K) * exp(-(x - y)^2 / (2σ^2))
#mutation kernel
mutation(x) = rand(truncated(Normal(x, 0.1), -1, 1))
μ = 1/(K*log(K))
</code></pre><p>Given that we anticipate a relatively limited number of distinct traits to be present at any given time, but a considerable number of representatives for any given trait that we elect to implement this model with, we have opted to utilise dictionaries. Each trait is a key within the dictionary, with the value being a triple consisting of the size of the subpopulation and its intrinsic birth and death rate. By saving the birth and death rate, the need for repeated recalculation of the same rate in each step is avoided; instead, the rate is simply read from the dictionary. To illustrate,starting in a monomorphic equilibrium at the boudary <span>$x_0 = -1$</span>, the initial population state would be as follows.</p><pre><code class="language-julia hljs">x0 = -1.0

n0 = Dict(
        x0 =&gt; [
                (b(x0, σ_b) - d(x0,d)) / c(x0,x0,σ_c, K),
                b(x0, σ_b),
                d(x0,d)
                ]
        )</code></pre><p>In this manner, the rate values for each trait are stored in a cache once they are incorporated into the population. A similar approach is employed for the competition rates between individuals, with a dedicated dictionary being established to accommodate the various competition rates. In order to establish the competition dictionary, it is necessary to define the following function.</p><pre><code class="language-julia hljs">#Generate a cach dictionary for all competition rates between individuals from the population state ps
function generatecompdict(ps,competition)
    IndividualType = keytype(ps)
    Individuals = collect(keys(ps))
    #generate empty dictionary
    C = Dict{
        Tuple{IndividualType,IndividualType},
        Real
        }()
    #populate dictionary
    for x in keys(ps), y in keys(ps)
        C[(x,y)] = competition(x,y)
    end
    return C
end</code></pre><p>The cached values will be passed to the functions via the parameter variable. Additionally, the birth, death, mutation and competition functions, with their fixed parameter values, will be stored there. Furthermore, it is necessary to adjust all model parameters, including the variances of the Gaussian birth and competition rates, the population size, and the time frame.</p><pre><code class="language-julia hljs">t = 0:1000

par = (
        birth = x -&gt; b(x, 0.9),
        death = x -&gt; d(x,0.0),
        competition = (x, y) -&gt; c(x, y, 0.8, 1000),
        mutate = mutation,
        μ = 0.00015,
        K = 1000,
        compdict = generatecompdict(n0,(x, y) -&gt; c(x, y, 0.8, 1000)),
        historylength = length(t)
)</code></pre><div class="admonition is-info"><header class="admonition-header">History length</header><div class="admonition-body"><p>As the population history will be stored in the dictionary, it is necessary to inform the algorithm of the duration of the simulation. To this end, the field &quot;historylength&quot; must be added to the parameter variable.</p></div></div><p>The next step is to define the rates function. In this case, the rates are also provided as a dictionary. Each subpopulation has two rates: a birth rate and a death rate. These are calculated from the cache and written to the dictionary.</p><pre><code class="language-julia hljs">#define rates function
function rates!(rates::Dict,ps::Dict,pr)
    #iterate through current population
    for (x,vₓ) in ps
        #size of subpopulation
        nₓ = vₓ[1]
        #check if rates are already cached, if not do so
        !haskey(rates,x) &amp;&amp; (rates[x] = valtype(rates)(undef,2))
        #birthrate n_x * b(x)
        rates[x][1] = nₓ*vₓ[2]
        #deathrate n_x * (d(x) + Σ c(x,y) n_y)
        rates[x][2] = nₓ* vₓ[3]
        for (traittuple,c) in pr.compdict
            t₁,t₂ = traittuple
            t₁ == x &amp;&amp; (rates[x][2] += nₓ * ps[t₂][1] * c)
        end
    end
end</code></pre><p>The process of adding a new trait to the population at birth is rendered challenging by the presence of extensive caching, particularly in relation to competition rates. Consequently, a preliminary function is first devised to facilitate the addition of new traits to the population, prior to the implementation of the <code>birth!</code> and <code>death!</code> functions.</p><pre><code class="language-julia hljs">#add a new trait to current population
function addnewtrait!(ps,rates,par,trait)
    #add to population state
    ps[trait] = [par.diff,par.birth(trait),par.death(trait)]
    #set competition
    for other_trait in keys(ps)
        par.compdict[(trait,other_trait)] = par.competition(trait,other_trait)
        par.compdict[(other_trait,trait)] = par.competition(other_trait,trait)
    end
end</code></pre><p>The <code>birth!</code> and <code>death!</code> functions can now be defined with relative ease and combined into a single <code>execute!</code> function.</p><pre><code class="language-julia hljs">function birth!(ps, rates, par, trait)
    #Birth with or without mutation
    if par.μ &gt; 0.0 &amp;&amp; rand() ≤ par.μ
        #mutate to new type/species and add to species
        new_trait = par.mutate(trait)
        #setup the size of the new type
        if haskey(ps,new_trait)
            ps[new_trait][1] += par.diff
        else
            addnewtrait!(ps,rates,par,new_trait)
        end
    else
        ps[trait][1] += par.diff
    end
    nothing
end

function death!(ps,trait,pr)
    ps[trait][1] -= pr.diff
end

function execute!(i,trait,ps,rates,pr)
    if i==1
        birth!(ps, rates, pr, trait)
    elseif i==2
        death!(ps,trait,pr)
    else
        error(&quot;Index Error: Unknown event #$i&quot;)
    end
end</code></pre><p>To initiate the simulation, it is merely necessary to establish an empty rates dictionary and population history, and then to execute the <a href="manual.html#DenseGillespieAlgorithm.run_gillespie!"><code>run_gillespie!</code></a> function.</p><pre><code class="language-julia hljs">#empty population history
hist = Dict(x=&gt;zeros(eltype(valtype(n0)),length(t)) for x in keys(n0))
#empty rates dictionary (gets populated in first iteration)
initrates = Dict{keytype(n0),Vector{Real}}()

#execute the simulation
run_gillespie!(
        t,
        n0,
        par,
        execute!,
        rates!,
        initrates,
        hist
)</code></pre><p>To observe the findings, the size of the subpopulations is plotted over time, with the different traits represented by varying colours.</p><pre><code class="language-julia hljs">using Plots

#setup plot
p=plot(legend=false)

#function to determine the color of the trait
function c(x)
    #find the biggest and smallest key in the population history
    min = min(keys(hist)...)
    max = max(keys(hist)...)
    
    #if there ever has been only one trait return 1 otherwise a color inbetween 
    if min == max
        return 1
    else
        return floor(Integer,((x-min)/(max-min)) * length(cgrad(:thermal))-1) + 1
    end
end

for (x,his_x) in history
    plot!(p,time,his_x,color=cgrad(:thermal).colors.colors[c(x)])
end

p</code></pre><p><img src="https://roccminton.github.io/images/TSS.png" alt="Simulation result with a mutation rate of 1/K"/></p><div class="admonition is-warning"><header class="admonition-header">Mutation rate</header><div class="admonition-body"><p>In this scenario, the runtime of the algorithm is highly dependent on the mutation rate. An increase in the mutation rate results in a greater number of different traits. This implementation with dictionaries is most suited for a small number of traits being alive at the same time. However, if the mutation rate is increased to levels of frequent mutation, it is recommended that dictionaries are not used, but instead vectors should be employed for saving the data. The following example demonstrates this technique.</p></div></div><div class="admonition is-success"><header class="admonition-header">Population size</header><div class="admonition-body"><p>Nevertheless, increasing the population size in this scenario does not significantly prolong the runtime of the algorithm. This is an advantage of using dictionaries and caching the competition. However, this approach is only effective when the mutation rate is scaled with the population size (as demonstrated in the above example).</p></div></div><div class="admonition is-info"><header class="admonition-header">Empty cache</header><div class="admonition-body"><p>It should be noted that the algorithm performs regular checks for subpopulations in the dictionary with a population size of zero. In the event that such subpopulations are identified, they are removed in order to prevent an excessive expansion of the dictionary. This process is carried out by the <a href="index.html#DenseGillespieAlgorithm.dropzeros!-Tuple{Any}"><code>DenseGillespieAlgorithm.dropzeros!</code></a> function.</p></div></div><h2 id="High-dimensional-model"><a class="docs-heading-anchor" href="#High-dimensional-model">High-dimensional model</a><a id="High-dimensional-model-1"></a><a class="docs-heading-anchor-permalink" href="#High-dimensional-model" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Dieckmann99"><a class="tag is-link" href="#citeref-Dieckmann99">Dieckmann99</a>U. Dieckmann, M. Doebeli, On the origin of species by sympatric speciation. <em>Nature</em> 400:354-357, 1999</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="manual.html">« Manual</a><a class="docs-footer-nextpage" href="perform.html">Performance Tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 18 September 2024 09:48">Wednesday 18 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
