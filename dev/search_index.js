var documenterSearchIndex = {"docs":
[{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Three illustrative examples are provided. The first is a minimal working example, designed to facilitate the initial implementation of the framework on the user's machine. The second is a slightly more advanced example, which illustrates the use of an uncountable trait space and caching for performance improvement in a particular use case. The third is a highly complex example, which demonstrates the comprehensive versatility of the package. ","category":"page"},{"location":"examples.html#1.-SIR-Model","page":"Examples","title":"1. SIR-Model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The SIR model is a tree-dimensional model that is used to model infectious diseases. It is a simple model that assumes that individuals can be placed into one of three categories: susceptible, infected, or recovered. Infected individuals can infect susceptible individuals through random interactions. After becoming infected, individuals can recover and become immune. For more details, see for example here.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The initial step is to implement the fundamental interaction functions. In this scenario, two events are occurring: infection and recovery. The objective is to implement these functions in a manner that modifies the population state, which is represented as a vector with three entries, one for each possible state of an individual.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots\nusing DenseGillespieAlgorithm\n\n# Define the reactions\nfunction infection!(x)\n    x[1] += -1\n    x[2] += 1\n    nothing\nend\n\nfunction recovery!(x)\n    x[2] += -1\n    x[3] += 1\n    nothing\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The subsequent step is to combine the aforementioned two functions into a single execute function, which will subsequently be provided to the algorithm.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#Combine all reactions into one execute! function\nfunction execute!(i,x,par)\n    if i == 1\n        infection!(x)\n    elseif i == 2\n        recovery!(x)\n    else\n        error(\"Unknown event number i = $i\")\n    end\n    nothing\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Furthermore, define the rate at which the events occur, which also depends on the population state. It should be noted that a modification of an existing variable that holds the current rates is necessary. In this case, as there are two events, namely infection and recovery, the rates variable will be a vector with two entries.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Define the reactions (reaction rates and species interactions)\nfunction rates!(rates,x,par)\n    #rate of infection\n    rates[1] = par.β * x[1] * x[2]\n    #rate of recovery\n    rates[2] = par.γ * x[2]\n    nothing\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Prior to commencing the study, it is essential to define all relevant model parameters. These include the interaction rates, the initial population state and the time horizon for the simulation. Prior to commencing the simulation, it is essential to define all relevant model parameters. These include the interaction rates, the initial population state and the time horizon for the simulation. Additionally, it is necessary to provide the algorithm with an empty population history, which will be populated with data during runtime.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#Define the model parameter \npar = (\n    β = 0.000005,\n    γ = 0.005\n    )\n\n# Define the initial state of the system \nx0 = [9999,1,0]\n\n# Define the time horizon for the simulation\nt = 0:2000\n\n# Initialize population history\nhist = zeros(Int,(length(t),3))","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"At this point in the process, all the necessary components have been put in place, and the task can be handed over to the core function of the package. Once the simulation has been executed, the results are plotted.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Run the simulation\nrun_gillespie!(\n        t,x0,par,\n        execute!,rates!,\n        Vector{Float64}(undef,2),hist\n        )\n\n# Analyze or plot the result (example with a simple print)\nplot(hist,label=[\"S\" \"I\" \"R\"])","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: SIR Plot)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"note: Note\nWhile it is feasible to construct such straightforward examples using the DenseGillespieAlgorithm, this is not the typical application. For relatively simple models, the JumpProcess.jl package offers greater flexibility and facilitates the implementation process.","category":"page"},{"location":"examples.html#2.-Continuous-trait-space","page":"Examples","title":"2. Continuous trait space","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In this example, we consider an individual-based model of adaptive dynamics, wherein the trait space is a subset of the real line. It is therefore impossible to list all the types and interaction rates between them, as there are uncountably many. It is thus necessary to implement the rates and interactions in a dynamic manner. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In the context of adaptive dynamics models, individuals are characterised by a specific trait, which in this case is a real number. The mortality and fertility rates of individuals are contingent upon this trait. Moreover, competition among individuals is contingent upon the trait in question. Furthermore, at birth, with a probability of μ, the offspring undergoes a mutation and displays a distinct trait in comparison to its parents. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"For further insight into the subject of adaptive dynamics models, we would direct the reader to the lecture notes by Anton Bovier.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We present a specific case study of an adaptive dynamics model, originally proposed by Dieckmann and Doebeli[Dieckmann99]. Here the trait space is mathcalX = -11 subset mathbbR. The birth rate is given by b(x)=exp(-x^22sigma^2_b) for some sigma_b  0. The death rate is constant d(x) = d and the competion between individuals depends only on theri distance by c(xy)=exp(-(x-y)^22sigma^2_c) for some sigma_c  0. Moreover the mutation kernel, that chooses the new trait of an offspring at birth is a Gaussian law with mean 0 and variance 01 conditioned to -11.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"[Dieckmann99]: U. Dieckmann, M. Doebeli, On the origin of species by sympatric speciation. Nature 400:354-357, 1999","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The next step is to begin the implementation of this model, starting with the rates function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Distributions\n\n#birth rate\nb(x, σ) = exp(-x^2 / (2σ^2))\n#death rate\nd(x,d) = d\n#competiton kernel\nc(x, y, σ, K) = inv(K) * exp(-(x - y)^2 / (2σ^2))\n#mutation kernel\nmutation(x) = rand(truncated(Normal(x, 0.1), -1, 1))\n","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Given that we anticipate a relatively limited number of distinct traits to be present at any given time, but a considerable number of representatives for any given trait that we elect to implement this model with, we have opted to utilise dictionaries. Each trait is a key within the dictionary, with the value being a triple consisting of the size of the subpopulation and its intrinsic birth and death rate. By saving the birth and death rate, the need for repeated recalculation of the same rate in each step is avoided; instead, the rate is simply read from the dictionary. To illustrate,starting in a monomorphic equilibrium at the boudary x_0 = -1, the initial population state would be as follows.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"x0 = -1.0\n\nn0 = Dict(\n        x0 => [\n                (b(x0, σ_b) - d(x0,d)) / c(x0,x0,σ_c, K),\n                b(x0, σ_b),\n                d(x0,d)\n                ]\n        )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In this manner, the rate values for each trait are stored in a cache once they are incorporated into the population. A similar approach is employed for the competition rates between individuals, with a dedicated dictionary being established to accommodate the various competition rates. In order to establish the competition dictionary, it is necessary to define the following function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#Generate a cach dictionary for all competition rates between individuals from the population state ps\nfunction generatecompdict(ps,competition)\n    IndividualType = keytype(ps)\n    Individuals = collect(keys(ps))\n    #generate empty dictionary\n    C = Dict{\n        Tuple{IndividualType,IndividualType},\n        Real\n        }()\n    #populate dictionary\n    for x in keys(ps), y in keys(ps)\n        C[(x,y)] = competition(x,y)\n    end\n    return C\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The cached values will be passed to the functions via the parameter variable. Additionally, the birth, death, mutation and competition functions, with their fixed parameter values, will be stored there. Furthermore, it is necessary to adjust all model parameters, including the variances of the Gaussian birth and competition rates, the population size, and the time frame.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"t = 0:1000\n\npar = (\n        birth = x -> b(x, 0.9),\n        death = x -> d(x,0.0),\n        competition = (x, y) -> c(x, y, 0.8, 1000),\n        mutate = mutation,\n        μ = 0.00015,\n        K = 1000,\n        compdict = generatecompdict(n0,(x, y) -> c(x, y, 0.8, 1000)),\n        historylength = length(t)\n)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"info: History length\nAs the population history will be stored in the dictionary, it is necessary to inform the algorithm of the duration of the simulation. To this end, the field \"historylength\" must be added to the parameter variable.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The next step is to define the rates function. In this case, the rates are also provided as a dictionary. Each subpopulation has two rates: a birth rate and a death rate. These are calculated from the cache and written to the dictionary.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#define rates function\nfunction rates!(rates::Dict,ps::Dict,par)\n    #iterate through current population\n    for (x,vₓ) in ps\n        #size of subpopulation\n        nₓ = vₓ[1]\n        #check if rates are already cached, if not do so\n        !haskey(rates,x) && (rates[x] = valtype(rates)(undef,2))\n        #birthrate n_x * b(x)\n        rates[x][1] = nₓ*vₓ[2]\n        #deathrate n_x * (d(x) + Σ c(x,y) n_y)\n        rates[x][2] = nₓ* vₓ[3]\n        for (traittuple,c) in par.compdict\n            t₁,t₂ = traittuple\n            t₁ == x && (rates[x][2] += nₓ * ps[t₂][1] * c)\n        end\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The process of adding a new trait to the population at birth is rendered challenging by the presence of extensive caching, particularly in relation to competition rates. Consequently, a preliminary function is first devised to facilitate the addition of new traits to the population, prior to the implementation of the birth! and death! functions.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#add a new trait to current population\nfunction addnewtrait!(ps,rates,par,trait)\n    #add to population state\n    ps[trait] = [par.diff,par.birth(trait),par.death(trait)]\n    #set competition\n    for other_trait in keys(ps)\n        par.compdict[(trait,other_trait)] = par.competition(trait,other_trait)\n        par.compdict[(other_trait,trait)] = par.competition(other_trait,trait)\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The birth! and death! functions can now be defined with relative ease and combined into a single execute! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function birth!(ps, rates, par, trait)\n    #Birth with or without mutation\n    if par.μ > 0.0 && rand() ≤ par.μ\n        #mutate to new type/species and add to species\n        new_trait = par.mutate(trait)\n        #setup the size of the new type\n        if haskey(ps,new_trait)\n            ps[new_trait][1] += par.diff\n        else\n            addnewtrait!(ps,rates,par,new_trait)\n        end\n    else\n        ps[trait][1] += par.diff\n    end\n    nothing\nend\n\nfunction death!(ps,trait,pr)\n    ps[trait][1] -= par.diff\nend\n\nfunction execute!(i,trait,ps,rates,pr)\n    if i==1\n        birth!(ps, rates, pr, trait)\n    elseif i==2\n        death!(ps,trait,pr)\n    else\n        error(\"Index Error: Unknown event #$i\")\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To initiate the simulation, it is merely necessary to establish an empty rates dictionary and population history, and then to execute the run_gillespie! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#empty population history\nhist = Dict(x=>zeros(eltype(valtype(n0)),length(t)) for x in keys(n0))\n#empty rates dictionary (gets populated in first iteration)\ninitrates = Dict{keytype(n0),Vector{Real}}()\n\n#execute the simulation\nrun_gillespie!(\n        t,\n        n0,\n        par,\n        execute!,\n        rates!,\n        initrates,\n        hist\n)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To observe the findings, the size of the subpopulations is plotted over time, with the different traits represented by varying colours.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots\n\n#function to determine the color of the trait\nfunction c(x)\n    #find the biggest and smallest key in the population history\n    min = min(keys(hist)...)\n    max = max(keys(hist)...)\n    \n    #if there ever has been only one trait return 1 otherwise a color inbetween \n    if min == max\n        return 1\n    else\n        return floor(Integer,((x-min)/(max-min)) * length(cgrad(:thermal))-1) + 1\n    end\nend\n\n#setup plot\np=plot(legend=false)\n\nfor (x,his_x) in history\n    plot!(p,time,his_x,color=cgrad(:thermal).colors.colors[c(x)])\nend\n\np","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: Simulation result with a mutation rate of 1/K)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Simulation results with a mutation rate of 1K where K is the carrying capacity.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"warning: Mutation rate\nIn this scenario, the runtime of the algorithm is highly dependent on the mutation rate. An increase in the mutation rate results in a greater number of different traits. This implementation with dictionaries is most suited for a small number of traits being alive at the same time. However, if the mutation rate is increased to levels of frequent mutation, it is recommended that dictionaries are not used, but instead vectors should be employed for saving the data. The following example demonstrates this technique.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tip: Population size\nNevertheless, increasing the population size in this scenario does not significantly prolong the runtime of the algorithm. This is an advantage of using dictionaries and caching the competition. However, this approach is only effective when the mutation rate is scaled with the population size (as demonstrated in the above example).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"info: Empty cache\nIt should be noted that the algorithm performs regular checks for subpopulations in the dictionary with a population size of zero. In the event that such subpopulations are identified, they are removed in order to prevent an excessive expansion of the dictionary. This process is carried out by the DenseGillespieAlgorithm.dropzeros! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"info: Switch-off caching\nIt is possible to implement the same dynamics without the caching of competition rates. In this case, the only necessary modification is to alter the for-loop in the rates! function, which iterates over all pairs of tuples tofor t₁ in keys(ps)\n    rates[x][2] += nₓ * ps[t₁][1] * par.competition(x,t₁)\nendand delete the for-loop over all other traits in the addnewtrait! function. In instances where the number of distinct traits is considerable, this approach is advised.","category":"page"},{"location":"examples.html#3.-High-dimensional-model","page":"Examples","title":"3. High-dimensional model","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The final example we will present is the most complex. We implement a model to analyse the dynamics of complete recessive lethal diseases. Each disease is triggered by the mutation of a gene and is expressed only in a homozygous state. Therefore, the traitspace for this model is mathcalX=01^2times N where N is the number of genes. A detailed description and results of numerous simulations with this exact framework can be found here[LaRocca24].","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"[LaRocca24]: L. A. La Rocca, K. Gerischer, A. Bovier, and P. M. Krawitz. Refining the drift barrier hypothesis: a role of recessive gene count and an inhomogeneous muller's ratchet, 2024","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Individuals expressing a disease are excluded from the mating process. At birth, each individual randomly selects a fit partner from the population. Following the process of recombination, whereby the diploid genetic information is reduced to a haploid zygote incorporating crossover events, the gametes of the two parents fuse to form a new offspring. New mutations emerge at a constant rate.  It is assumed that the intrinsic death rate and the competition among all individuals are identical. Only the birth rate is reduced to zero for infected individuals.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Given that there are 2^2N potential configurations with interactions between them, it is not feasible to enumerate them all prior to the start of the simulation.  Furthermore, it is of no particular interest to ascertain the precise genetic configuration of the entire population. Typically, one is only concerned with summary statistics, such as the mutation burden (the average number of mutations per individual) and the prevalence (the fraction of individuals affected by a disease). It is therefore only these statistics that will be retained for subsequent analysis. However, for the propagation of the population dynamics, it is essential to have access to the exact configurations. To be more precise, the total birth and death rates can be calculated via the summary statistics, which we utilise. However, in order to employ an offspring, the configurations are required.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In order to enhance the efficacy of the algorithm, it is essential to make extensive use of the parameter variable, which is passed to all relevant functions. The intrinsic configuration is stored therein in an optimal way, while the population state encompasses only the summary statistics and the total population size, as these are the necessary components for computing the event rates.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The initial stage of the process entails the establishment of all model-specific parameters, including the constant birth, death, and competition rates; the expected number of mutations at birth, denoted by μ; the number of recessive genes; the initial population size; and the recombination rate.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using SparseArrays\nusing Random\n\nt = 0:1000\n\npar = (\n    birth = 1.0,\n    death = 0.9,\n    competition = 0.1 / 1000,\n    μ = 0.1,\n    Nloci = 100,\n    K = 1000,\n    recombination = 0.01\n)\n\nn0 = Dict(\n    \"PopSize\" => par.K,\n    \"Ill\" => 0,\n    \"ML\" => 0\n)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The only two possible events are birth and death, the rates! function can be expressed as follows: ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function rates!(rates, ps, par)\n    #linear birth for all propagable individuals\n    rates[1] = par.birth * (ps[\"PopSize\"]-ps[\"Ill\"])\n    #uniform logistic death\n    rates[2] = ps[\"PopSize\"] * par.death + ps[\"PopSize\"] * (ps[\"PopSize\"] - 1) * par.competition\n    nothing\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The definition of the function that executes the birth is a more challenging undertaking, given that it involves three mechanisms: mating, recombination and mutation.  Nevertheless, prior to an explication of the implementation of the execute! function, it is necessary to describe the means by which the population configuration is saved internally. Since the size of any given trait is relatively large (2N bytes), and since we anticipate a significant number of different traits, but a limited population size, we have chosen to construct a vector of traits that is as large as the expected population size, with additional space for fluctuations. This vector will store all the traits. Furthermore, a dictionary of indices is maintained, which points to the indices of traits in the vector. The dictionary differentiates between traits that are either alive and healthy, or alive but ill (thus expressing the disease and unable to reproduce), or that are not part of the current population. The aforementioned free traits can then be modified if new offsprings are born, eliminating the necessity of initiating a new 2 times N matrix of Bools each time. This method allows for the saving of a considerable amount of memory. The production of new traits is dependent upon the absence of free indices. Upon the death of a fey individual, the index is released into the group of free indices, where it may be reborn as a new trait at a future point in time. In order to initiate the trait vector, which encompasses all individual genetic configurations, we have implemented a function that takes the initial population state as an input and draws a possible trait configuration from it. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#empty genetic configuration\nemptytraits(Nloci,T=Bool) = [spzeros(T,Nloci),spzeros(T,Nloci)]\n\n#produce trait collection from population state\nfunction inittraits(par,n0)\n    #Setup healthy genetic information\n    locs = 1:par.Nloci\n    #Generate healty population with some buffer for fluctuations\n    traits = [emptytraits(par.Nloci) for _ in 1:round(Int,par.K + sqrt(par.K))]\n    #add two mutations to completely healthy individuals to get the required number of ill individuals\n    for i in 1:n0[\"Ill\"]\n        l = rand(locs)\n        traits[i][1][l] = 1\n        traits[i][2][l] = 1\n    end\n    individuals = 1:n0[\"PopSize\"]\n    #add the remaining mutaions to the population to get the required mutation load\n    for i in n0[\"Ill\"]+1:n0[\"ML\"]-2*n0[\"Ill\"]\n        #choose random individual and location\n        ind = rand(individuals)\n        l = rand(locs)\n        #recoose random individual and location if the individual has already a mutation\n        #at that locationo or at the homologe gene\n        while traits[ind][1][l]+traits[ind][2][l] ≠ 0\n            ind = rand(individuals)\n            l = rand(locs)\n        end\n        traits[ind][rand(par.choosecopyfrom)][l] = 1\n    end\n    return traits\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Subsequently, both the traits and the corresponding index dictionary are incorporated into the parameter variable. Additionally, other necessary elements are included, allowing for their reuse rather than generation on each occasion. These include a vector of random numbers for mate selection, the mutation distribution, the distribution of mutation locations and a unit range for gene segment selection.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"par = (par...,\n    rndm = Vector{Int}(undef,2),\n    MutationsPerBirth = Poisson(par.μ),\n    MutationLocation = 1:par.Nloci,\n    traits = inittraits(par,n0),\n    indices = Dict(\n        \"healthy\" => collect(n0[\"Ill\"]+1:n0[\"PopSize\"]),\n        \"ill\" => collect(1:n0[\"Ill\"]),\n        \"free\" => collect(n0[\"PopSize\"]+1:round(Int,par.K + sqrt(par.K)))\n    ),\n    historylength = length(t),\n    choosecopyfrom = 1:2,\n)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The initial step on implementing the birth! function is to implement a function that establishes the crossover breakpoints for recombination at random, in accordance with the specified recombination rate. The function initially draws the number of crossover breakpoints from a Poisson distribution, and subsequently selects the position at random from among all N-1 positions. The resulting vector of UnitRange segments is then returned.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#output for recombination rate 1\nfullreccuts(par) = [i:i for i in 1:par.Nloci]\n#output for recombination rate 0\nnoreccuts(par) = [1:par.Nloci]\n\nfunction reccuts(par)\n    if par.recombination == 1\n        return fullreccuts(par)\n    elseif par.recombination == 0\n        return noreccuts(par)\n    else\n        #draw number of chromosome cuts\n        ncuts = rand(Poisson(par.recombination*par.Nloci))\n        #equals full recombination\n        ncuts ≥ par.Nloci - 1 && return fullreccuts(par)\n        #equals no recombination\n        iszero(ncuts) && return noreccuts(par)\n        #otherwise produce individual segments at random\n        cutsat = sort!(sample(1:par.Nloci-1,ncuts,replace=false))\n        ccuts = [1:cutsat[1]]\n        for i in 2:length(cutsat)\n            push!(ccuts,cutsat[i-1]+1:cutsat[i])\n        end\n        push!(ccuts,cutsat[end]+1:par.Nloci)\n        return ccuts\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Subsequently, once two parents have been identified for mating, the process of the offspring generation is defined. This encompasses recombination, mating and mutation. The new genetic configuration of the offspring is stored at a designated index.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function offspring!(offspring_index, par, n_mut)\n    #randomly recombine the parental genetic information\n    #first for one then for the other parent\n    for i in par.choosecopyfrom # =1:2\n        #randomly choose one copy for each chromosome/gene block\n        ccuts = reccuts(par)\n        choosecopy = rand(par.choosecopyfrom,length(ccuts))\n        for (r,chromosome) in enumerate(ccuts)\n            view(par.traits[offspring_index][i],chromosome) .=\n                view(par.traits[par.rndm[i]][choosecopy[r]],chromosome)\n        end\n    end\n    #add n_mut mutations to random positions mutation\n    #if there are no mutations to add skip the mutation process\n    if n_mut > 0\n        for _ in 1:n_mut\n            par.traits[offspring_index][rand(par.choosecopyfrom)][rand(par.MutationLocation)] = 1\n        end\n    end\n    nothing\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The final step before integrating all components into a unified system is to implement a function that updates the population state following the generation of the offspring's genetic configuration.It is therefore necessary to ascertain whether the offspring in question exhibits a mutation in a homogeneous state, which would render it unsuitable for reproduction. Furthermore, the mutation burden of the offspring must be calculated.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#check if configuration has homogeneous mutation\nispropagable(a::Vector,Nloci) = ispropagable(a)\nfunction ispropagable(a::Vector)\n    for (i,p) in enumerate(a[1])\n        isone(p) && isone(a[2][i]) && return false\n    end\n    return true\nend\n#calculate mutation load\nmutationload(a::Vector) = sum(sum(svec) for svec in a)\n#modify population state at birth of offspring\nfunction updateps_birth!(ps,par,offspring_index)\n    if ispropagable(par.traits[offspring_index],par.Nloci)\n        push!(par.indices[\"healthy\"],offspring_index)\n    else\n        ps[\"Ill\"] += 1\n        push!(par.indices[\"ill\"],offspring_index)\n    end\n    ps[\"PopSize\"] += 1\n    ps[\"ML\"] += mutationload(par.traits[offspring_index])\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The aforementioned processes are unified in the birth! function, which initially identifies potential parents for mating, subsequently generates offspring, and finally updates the population state. ","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#execute the addition of an individual\nfunction birth!(ps, par)\n    #choose two genetic configurations to mate\n    rand!(par.rndm,par.indices[\"healthy\"])\n    #clean up parental configurations\n    for i in par.choosecopyfrom, j in par.choosecopyfrom\n        dropzeros!(par.traits[par.rndm[i]][j])\n    end\n    #select free index for offspring\n    if isempty(par.indices[\"free\"])\n        offspring_index = length(par.traits) + 1\n        push!(par.traits,emptytraits(par.Nloci))\n    else\n        offspring_index = pop!(par.indices[\"free\"])\n    end\n    #generate offsprings genetic configuration\n    offspring!(offspring_index, par, rand(par.MutationsPerBirth))\n    #add the individual to the current population state dictionary\n    updateps_birth!(ps,par,offspring_index)\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The removal of an individual at death is a relatively straightforward process. It merely entails freeing the index and updating the population state in accordance with the relevant changes.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#modify population state at death of an individual\nfunction updateps_death!(ps,par,fey_index)\n    ps[\"PopSize\"] -= 1\n    ps[\"ML\"] -= mutationload(par.traits[fey_index])\nend\n#execute the removal of an individual\nfunction death!(ps, par)\n    #choose fey\n    if rand()<=ps[\"Ill\"]/ps[\"PopSize\"]\n        fey_index = popat!(par.indices[\"ill\"],rand(1:ps[\"Ill\"]))\n        ps[\"Ill\"] -= 1\n    else\n        fey_index = popat!(par.indices[\"healthy\"],rand(1:(ps[\"PopSize\"]-ps[\"Ill\"])))\n    end\n    #add fey to gravejard\n    push!(par.indices[\"free\"],fey_index)\n    #update population state\n    updateps_death!(ps,par,fey_index)\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As in the preceding cases, it is necessary to collate both the birth! and death! functions into a single execute! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function execute!(i,ps,par)\n    if i == 1\n        birth!(ps,par)\n    elseif i == 2\n        death!(ps,par)\n    else\n        error(\"Unknown event index: $i\")\n    end\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Finally, the simulation can be executed following the initialisation of both a blank rates vector and a blank population history.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#setup empty rates vector\ninitrates = Vector{typeof(par.birth)}(undef,2)\n\n#setup empty population history\nhist = Dict(x=>zeros(valtype(n0),length(t)) for x in keys(n0))\n\nrun_gillespie!(\n        t,n0,\n        par,\n        execute!,\n        rates!,\n        initrates,\n        hist\n        )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In order to facilitate the analysis of the data, we present a straightforward graphical representation.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots\n#plot the prevalence\nplot(t,hist[\"Ill\"] ./ hist[\"PopSize\"],color=:orange,label=\"\")\n#plot the population size (without axis ticks)\nplot!(twinx(),hist[\"PopSize\"],color=:gray,yticks=false,label=\"\")\n#plot the mutation burden\nplot!(twinx(),hist[\"ML\"] ./ hist[\"PopSize\"],color=:red,label=\"\")","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"warning: Population extinction\nIn the event of the population becoming extinct, the aforementioned method will result in an error, as the division of zero will occur. To circumvent this issue, it is recommended to first invoke the following function on the data set.replace_NaN(v) = map(x -> isnan(x) ? zero(x) : x, v)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: Simulation result showing the mutation load, prevalence and population size)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The grey line represents the population size, which is not represented by any axis. On the left y-axis, the prevalence is represented by the yellow line, while the mutation burden is shown by the red line on the right y-axis.","category":"page"},{"location":"examples.html#Custom-statistic!-function","page":"Examples","title":"Custom statistic! function","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Thus far, the only function employed for the purpose of saving the population history was the built-in DenseGillespieAlgorithm.saveonestep! function, which in this case saves the mutation burden, prevalence, and population size over time. However, given the intricate population structure of the model, it may be beneficial to consider saving additional statistics that extend beyond mere numbers over time. For this example, we are interested in saving the allele frequencies of the mutated allele per position over time. This necessitates the definition of a custom statistic! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The initial step is to incorporate an additional function call into the existing functions updateps_death! and updateps_birth! of the form updatestats_death!(ps, par, fey_index) and updatestats_birth!(ps, par, offspring_index), respectively. This allows us to modify the new statistic that we wish to utilise at each event, rather than recalculating it from the current population state after every full time step, which is the usual process.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tip: Empty functions\nIn the event that there is no intention to update the statistical data at each stage, it is nonetheless recommended that the function call updatestats_event! be retained in order to ensure the flexibility and reusability of the code. In the absence of a required function, the implementation of a generic function of the form function updatestats_death! end\nfunction updatestats_birth! endis sufficient.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In order to enhance the flexibility of the system, a custom data type has been defined to accommodate the various statistical elements associated with the population history. This approach facilitates the incorporation of new statistics, should the need arise.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#type to hold population history\nstruct PopHist\n    #mutation burden, prevalence and population size\n    mlp :: Dict \n    #allele frequencies per postion\n    loadpos :: Array\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"note: Unmutable struct\nIt is important to note that the variable type of the population history has been defined as unmutable, which may appear counterintuitive at first glance. However, upon closer examination, it becomes evident that the elements within the struct are only generated once and then populated with data. Meanwhile, the container itself (array, dict, etc.) remains unchanged. This allows for the use of a faster and lighter unmutable object. Conversely, if there is a need to modify the fields within the struct, it would be necessary to define it as a mutable struct.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We choose to save the allele frequencies of the mutated allele at each position as a Ttimes N  matrix, where T is the total length of the simulation. Each column of the matrix represents the allele frequencies for a single time step. In fact, we will save the precise number of mutations per gene, leaving the division by the population size to be performed subsequently, once the simulation has been completed. In order to utilise the enhanced performance afforded by the addition of the updatestats_event function, it is necessary to create a temporary storage location for the current allele frequencies prior to their final saving to the storage medium for subsequent analysis. Once again, the parameter variable that is passed to every significant function is employed for this purpose.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#add blank current allele frequencies to parameter variable\npar = (\n    par...,\n    cafs = zeros(Int,par.Nloci)\n)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Given the type configuration that is added or removed from the population, the adjustment of the current allele frequencies is a relatively straightforward process.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#add or remove one individual from allele frequency vector\nfunction update_allelefreqs!(af,ind,i)\n    af .+= i .* ind[1]\n    af .+= i .* ind[2]\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Furthermore, the corresponding functions for birth and death can be developed upon this function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"updatestats_death!(ps,par,index) = update_allelefreqs!(par.cafs,par.traits[index],-1)\nupdatestats_birth!(ps,par,index) = update_allelefreqs!(par.cafs,par.traits[index],+1)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The additional statistics have now been incorporated into the system, and the next stage is to save the data at each time step within the specified time horizon into the PopHist type. This process is carried out by the following function. Additionally, the function responsible for saving the supplementary statistical data is merged with the one that stores the mutation burden, prevalence, and population size, which were previously saved in the basic example. This allows the creation of the custom statistic! function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"function saveafs!(allelefreqs,index,ps,par)\n        view(allelefreqs,index,:) .= par.cafs\nend\n\nfunction statistic!(pophist::PopHist,index,ps,par)\n    #save standard statistic\n    DenseGillespieAlgorithm.saveonestep!(pophist.mlp,index,ps,par)\n    #save additional statistic\n    saveafs!(pophist.allelefreqs,index,ps,par)\n   end","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"As previously described, the final stage of the process is to set up the initial rates, the initial population history, and then to execute the run_gillespie! function together with the newly defined statistic! function as a keyword argument.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"#setup empty rates vector\ninitrates = Vector{typeof(par.birth)}(undef,2)\n\n#setup empty population history\nhist = PopHist(\n    Dict(x=>zeros(valtype(n0),length(t)) for x in keys(n0)),\n    zeros(Integer,(length(t),par.Nloci,))\n    )\n\nrun_gillespie!(\n        t,n0,\n        par,\n        execute!,\n        rates!,\n        initrates,\n        hist,\n        statistic! =statistic!\n        )","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To analyse the data, one possible approach would be to construct a small GIF that generates plots of the allele frequencies at each position over time.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots\n\n#calculate frequencies from absolute numbers of mutations\nafs = hist.allelefreqs ./ hist.mlp[\"PopSize\"]\n#maximal frequencie for axis limit\nymax = maximum(afs)\n#create animation\nanim = @animate for i in 0:100\n    bar(view(afs,i+1,:),ylim=(0,ymax),label=\"\")\nend every 10\n#show animation\ngif(anim)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: Animation of allele frequencies over time)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tip: Time intervals\nIn certain instances, the requisite statistic may require a considerable amount of memory space or a significant amount of time to calculate. In such cases, it may be more efficient to save and calculate the statistic not in every time step, but rather only after larger intervals. This can be achieved in two ways. First, the time horizon provided to the algorithm can be adjusted to a coarser resolution, for instance, 0:10:1000 instead of 0:1000, resulting in a step size of 10 rather than 1. It should be noted that in such instances, the events continue to occur at the (potentially very small) event rates, but the saving mechanism is executed at each full time step. In this scenario, however, all the statistics that are generated are saved exclusively at the larger time steps. Second, in the event that a specific statistic is particularly resource-intensive, it is possible to implement an if condition within the statistics! function that will then save the statistic only if the time index meets the specified condition.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"tip: Snapshots\nIt is a source of considerable frustration to have invested a significant amount of time in running a comprehensive simulation only to realise, upon completion, that an alternative statistic might also warrant examination. Consequently, it was beneficial on occasion to also take \"snapshots\" at every couple of generations. Therefore, a random sample of the population was selected and all the information for that subpopulation was stored. As the population size was reduced by taking a sample from the population and the time horizon was reduced by taking these snapshots on a coarse time grid, the amount of memory required remained within acceptable limits.","category":"page"},{"location":"perform.html#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"One of the key benefits of the Gillespie algorithm is its ability to trace a single, precise stochastic trajectory. Nevertheless, in order to achieve this for each individual event, the rates must be calculated and re-calculated whenever there is a change in the population configuration. This makes the algorithm computationally demanding. There are numerous modifications that can be made in order to enhance performance, such as tau-leaping[Gillespie01]. However, in this section, our objective is to maintain the precision of the stochastic simulation and to identify potential bottlenecks and strategies for optimising the performance of the simulation in its current form.","category":"page"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"[Gillespie01]: D.T. Gillespie. Approximate accelerated stochastic simulation of chemically reacting systems. Journal of Chemical Physics, 115(4):1716-1733, 2001","category":"page"},{"location":"perform.html#Julia-performance-tips-and-benchmarking","page":"Performance Tips","title":"Julia performance tips and benchmarking","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"The Julia documentation contains a comprehensive and invaluable array of performance tips. Should you encounter any unexpected delays in your simulations, we advise you to consult these tips. It is likely that you will find a solution to the problem by following the guidance provided. Additionally, we recommend that you review the workflow tips and the style guide. These resources assist in enhancing the efficiency, readability, and overall quality of your code. In particular, we recommend these chapters of the documentation for researchers who are new to Julia. To assess the efficacy of the functions within your model, Julia offers an exemplary benchmarking package called BenchmarkingTools.jl. This enables the comparison of different versions of your code, facilitating the selection of the most optimal version.","category":"page"},{"location":"perform.html#Natural-bottleneck-in-Gillespies-Algorithm","page":"Performance Tips","title":"Natural bottleneck in Gillespies Algorithm","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"It should be noted that both the rates! and execute! functions will be called a considerable number of times during the course of the simulation. To illustrate, consider a species with a reproduction rate of 1 within a population of 1000 individuals over a time horizon of 1000 generations. In this scenario, the rates! and execute! functions will be called approximately one million times solely for reproduction events. Consequently, it is crucial to implement these functions with optimal performance. Every millisecond gained, every byte saved can significantly impact the runtime and efficiency of the program.","category":"page"},{"location":"perform.html#Reuse-memory-space","page":"Performance Tips","title":"Reuse memory space","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"Avoid to recreate containers such as arrays or dictionaries, particularly within the execute! and rates! function. Reuse of these containers is preferable to the allocation of new memory space with each iteration. The accumulation of data over the course of a simulation can lead to a reduction in performance.","category":"page"},{"location":"perform.html#Recalculate-vs.-update","page":"Performance Tips","title":"Recalculate vs. update","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"In certain scenarios, it is preferable to recalculate data from the current population state rather than update the data after every event, depending on the model and model parameter in question. For other models the opposite is may be true. In cases where there is uncertainty about the optimal implementation strategy, it is recommended to implement both versions and evaluate their performance using the BenchmarkingTools.jl package. This is the case for the event rates, which should be recalculated or updated depending on the circumstances and for the additional statistics that may be saved. However, it should be noted that the rates! function is usually called much more frequently than the statistics! function. The statistics are saved at regular intervals, as specified by the time horizon input to the algorithm, whereas the rates function is called after each event.","category":"page"},{"location":"perform.html#Keep-calm","page":"Performance Tips","title":"Keep calm","text":"","category":"section"},{"location":"perform.html","page":"Performance Tips","title":"Performance Tips","text":"The Gillespie Algorithm is a computationally intensive algorithm due to its exact nature. Following the implementation of complex networks on a high-dimensional trait space, the execution may require a significant amount of time. It is recommended to test the algorithm on a smaller scale, benchmark and adapt functions regularly, and only to be concerned if the time required to produce the simulation is unexpectedly long or if a disproportionate amount of memory is allocated. Otherwise, grab a coffee and check out the progress meter to see how things are going with the simulation.","category":"page"},{"location":"manual.html#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The DenseGillespieAlgorithm framework is designed to assist researchers in simulating their complex models in an exact stochastic manner. It is the responsibility of the user to implement all model-specific functions, such as those pertaining to birth and death events or rate functions. Once this has been done, the framework executes the Gillespie Algorithm and saves the population history. The following section provides an overview of the main function of this package.","category":"page"},{"location":"manual.html#Installation","page":"Manual","title":"Installation","text":"","category":"section"},{"location":"manual.html#Install-from-GitHub","page":"Manual","title":"Install from GitHub","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"You can install the package directly from this GitHub repository:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"using Pkg\nPkg.add(\"https://github.com/roccminton/DenseGillespieAlgorithm.jl\")","category":"page"},{"location":"manual.html#Install-from-Julia","page":"Manual","title":"Install from Julia","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Once the package is registered in the official Julia package registry, you can install it via:","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"using Pkg\nPkg.add(\"DenseGillespieAlgorithm\")","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"This will install the latest stable version of the package and all required dependencies.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"note: Package dependencies\nWhen loading the package directly from GitHub, the following packages must be available Random, Distributions, ProgressMeter, SparseArrays","category":"page"},{"location":"manual.html#Setting-up-the-model-functions","page":"Manual","title":"Setting up the model functions","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The initial step is to define all interaction functions for the model. In population models, these are typically limited to two: birth and death. However, there is no upper limit on the number of interactions that can be included. As the number of fundamentally different interactions increases, the efficiency of the algorithm is reduced. The framework is speciallised to a small number of different events.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Subsequently, all the interaction functions should be incorporated into a single execute function. This function must accept three inputs: an index, the current population state, and the model parameter. The index specifies which of the defined events should be executed. The current population state is then modified by the event functions. ","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"    execute!(i,x,par)","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Next we need to define the rates function. There must be as many rates as there are interaction events. Therefore the variable initrates is usually a Vector with as many entries as there are events. The rates function takes as input the inital rates, the current population state and the additional model parameters. The function should calculate the rates according to the population state and modify the initrates accordingly.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"    rates!(initrates,x,par)","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"note: Function names\nThe function name may be designated as desired, as they are passed to the ` function. The nomenclature is inconsequential.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"danger: Function signature\nNevertheless, it is crucial to maintain the original function signature, which entails retaining the sequence and the number of arguments as they are called within the algorithmic structure.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"tip: Parameter variable\nThere are no restrictions on the parameter variable par. Any additional information used to calculate rates and to change the current population state can be added to the parameter element that is passed through all functions. For example, if you want to know the current time of the simulation within the functions you run for time-inhomogeneous models, you could add this to your model parameter.","category":"page"},{"location":"manual.html#Setting-up-the-model-parameter,-population-history-and-initial-population","page":"Manual","title":"Setting up the model parameter, population history and initial population","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The final step before running the simulation is to define the model parameters, including the time horizon of the simulation and the initial population state, as well as a blank population history.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"The time horizon of the simulation is tipically a UnitRange, but can be anything that can be enumerated.  The type of initial population state should correspond to the functionalities defiend in the function rates! and execute! as they use and modify this type.  The empty population history should also match the type of population state, as it will be copied into the population history. In addition, if the population history is a vector or matrix, it should be at least as long as the time horizon. You can customise the saving process with your own Statistics! function. In this case, you will have to adapt the coupling history to the functionalities of this function. For more details, see Customized Statistics","category":"page"},{"location":"manual.html#Execute-the-simulation","page":"Manual","title":"Execute the simulation","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"With everything in place, it is time to run the simulations. To do this, call the run_gillespie! function from the package. ","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"run_gillespie!","category":"page"},{"location":"manual.html#DenseGillespieAlgorithm.run_gillespie!","page":"Manual","title":"DenseGillespieAlgorithm.run_gillespie!","text":"    run_gillespie!(time,n₀,par,execute!,rates!,initrates,population_history[,hstart=0,statistic!])\n\nRun a exact stochastic simulation, return and fill the population_history.\n\nArguments\n\ntime::AbstracVector: time interval for the simulation\nn₀: initial population state\npar: additional parameter (gets passed to execute! and rates!)\nexecute!: execute function\nrates!: rates function\ninitrates: initial rates\npopulation_history: empty population history\nhstart=0: time shift for parameter change (opitonal)\nstatistic!: additional statistic function (optional)\n\nExtended help\n\nNote that n₀,initrates,population_history all three get modified during the simulation\nThe algorithm expects the execute! function to have the following signature   julia   execute!(i::Number,n₀,par)   where the i is the event that gets executed and the population state n₀ gets modified accordingly.   The only exception is when the initrates are given as a dictionary. In that case the signature is execute!(i,trait,n₀,initrates,par), where 'trait'   is the key that is modified.\nThe algorithm expects the rates! function to have the following signature   julia   rates!(initrates,n₀,par)   where the rates get modified according to the current population state given in n₀.\nThe algorithm expects the statistic! function to have the following signature   julia   statistic!(population_hist,t,n₀,par)   where the population history gets modified at position t with the current population state n₀.\nNote that the population_history needs to be accessable via index from 1 to length(time), or if hstart is given from 1+hstart to length(time)+hstart. Unless a specified statistic! function is given.\nNote that the initial population state n₀ must match the population_history in the sense that population_history :: Vector{typeof(n₀)}.  Unless a specified statistic! function is given.\nThe parameter variable par is passed through all functions (execute!,rates!,statistics!), thereby affording the user additional flexibility.\n\n\n\n\n\n","category":"function"},{"location":"manual.html","page":"Manual","title":"Manual","text":"Once the simulation has reached its conclusion, the modified population history is returned for further analysis.","category":"page"},{"location":"manual.html#Customized-Statistics","page":"Manual","title":"Customized Statistics","text":"","category":"section"},{"location":"manual.html","page":"Manual","title":"Manual","text":"For many high-dimensional models, the exact configuration at any given time is too much information. In many cases only summery statistics are needed. To avoid accumulating too much data during the runtime of the algorithm that is not needed afterwards, you can define your own statistics! function. In this case, only the information you want to collect is stored for further analysis.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"As for the rates! and execute! functions, the function signature is of particular significance. The function accepts as input the population history, which is modified by the function and the current time index, hence the index at which the statistics of the current population state are saved. Additionally, the current state and the model parameter are required.","category":"page"},{"location":"manual.html","page":"Manual","title":"Manual","text":"    statistics!(population_history,t,x,par)","category":"page"},{"location":"index.html#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"index.html","page":"Public API","title":"Public API","text":"Puplic documentation of all internal functions. ","category":"page"},{"location":"index.html#Detailed-API","page":"Public API","title":"Detailed API","text":"","category":"section"},{"location":"index.html","page":"Public API","title":"Public API","text":"Modules = [DenseGillespieAlgorithm]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#DenseGillespieAlgorithm.chooseevent-Tuple{Any, Any}","page":"Public API","title":"DenseGillespieAlgorithm.chooseevent","text":"chooseevent(rates::Vector{Float64},total_rate::Float64)\n\nChoose from the vector of total rates at random one of the indices of the vector according to their rates.\nThe value 0 is returned if the total rates are positive, but too smale to let the evolution continue.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.chooseevent-Tuple{Dict, Any}","page":"Public API","title":"DenseGillespieAlgorithm.chooseevent","text":"chooseevent(rates::Dict,total_rate::Float64)\n\nChoose from the dictionary of total rates at random one of the keys of the dictionary according to their values.\nThe value 0 is returned if the total rates are positive, but too smale to let the evolution continue.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.dropzeros!-Tuple{Any}","page":"Public API","title":"DenseGillespieAlgorithm.dropzeros!","text":"    dropzeros!(ps)\n\nDo nothing for non-dictionary inputs.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.dropzeros!-Tuple{Dict{<:Any, <:Vector}}","page":"Public API","title":"DenseGillespieAlgorithm.dropzeros!","text":"    dropzeros!(ps::Dict{Any,Vector})\n\nEliminates all key value pairs for which the the firts entry of the vector of the value is zero.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.historylength-Tuple{Vector, Any}","page":"Public API","title":"DenseGillespieAlgorithm.historylength","text":"    historylength(population_hisotry,par)\n\nReturn the simulation time based on the length of the population history. If the population history is neither a Vector nor a Matrix it is assumed that the Parameter has a field called historylength that is then returned.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.mainiteration!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{Any, Any, Any, Any, Any, Any, F1, F2, F3, Any}} where {F1, F2, F3}","page":"Public API","title":"DenseGillespieAlgorithm.mainiteration!","text":"    mainiteration!(pop_hist,rates,n0,ct,time,par,ex!::F1,r!::F2,stat!::F3,hstart)\n\nMainiteration of the GillespieAlgorithm for complex models.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.mainiteration!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{Any, Any, Real, Any, Any, Any, F1, F2, F3, Any}} where {F1, F2, F3}","page":"Public API","title":"DenseGillespieAlgorithm.mainiteration!","text":"    mainiteration!(pop_hist,rates,n0::Real,ct,time,par,ex!::F1,r!::F2,stat!::F3,hstart)\n\nMainiteration of the GillespieAlgorithm for OneType Models where the population state is a number and the population history is a vector.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.nexteventandtime-Tuple{Any}","page":"Public API","title":"DenseGillespieAlgorithm.nexteventandtime","text":"nexteventandtime(rates::Vector{Float64})\n\nSample a exponential distributed random variable to determine the time for the next event and calls `choose_event`.\nThe return value is a tuple consiting of the envent index returned by `choose_event` and the time to the next event.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.nexteventandtime-Tuple{Dict}","page":"Public API","title":"DenseGillespieAlgorithm.nexteventandtime","text":"nexteventandtime(rates::Dict)\n\nSample a exponential distributed random variable to determine the time for the next event and calls `choose_event`.\nThe return value is a triple consiting of the envent index and trait returned by `choose_event` and the time to the next event.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.onestep!-Union{Tuple{F2}, Tuple{F1}, Tuple{Any, Any, Any, Any, Any, F1, F2}} where {F1, F2}","page":"Public API","title":"DenseGillespieAlgorithm.onestep!","text":"    onestep!(x_0,rates,t_0,t_end,par,ex!::F1,r!::F2)\n\nExecute one step of the evolution by modifying x_0 and rates and returning the current time t_0.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.run_gillespie!-Union{Tuple{F3}, Tuple{F2}, Tuple{F1}, Tuple{Any, Any, Any, F1, F2, Any, Any}} where {F1, F2, F3}","page":"Public API","title":"DenseGillespieAlgorithm.run_gillespie!","text":"    run_gillespie!(time,n₀,par,execute!,rates!,initrates,population_history[,hstart=0,statistic!])\n\nRun a exact stochastic simulation, return and fill the population_history.\n\nArguments\n\ntime::AbstracVector: time interval for the simulation\nn₀: initial population state\npar: additional parameter (gets passed to execute! and rates!)\nexecute!: execute function\nrates!: rates function\ninitrates: initial rates\npopulation_history: empty population history\nhstart=0: time shift for parameter change (opitonal)\nstatistic!: additional statistic function (optional)\n\nExtended help\n\nNote that n₀,initrates,population_history all three get modified during the simulation\nThe algorithm expects the execute! function to have the following signature   julia   execute!(i::Number,n₀,par)   where the i is the event that gets executed and the population state n₀ gets modified accordingly.   The only exception is when the initrates are given as a dictionary. In that case the signature is execute!(i,trait,n₀,initrates,par), where 'trait'   is the key that is modified.\nThe algorithm expects the rates! function to have the following signature   julia   rates!(initrates,n₀,par)   where the rates get modified according to the current population state given in n₀.\nThe algorithm expects the statistic! function to have the following signature   julia   statistic!(population_hist,t,n₀,par)   where the population history gets modified at position t with the current population state n₀.\nNote that the population_history needs to be accessable via index from 1 to length(time), or if hstart is given from 1+hstart to length(time)+hstart. Unless a specified statistic! function is given.\nNote that the initial population state n₀ must match the population_history in the sense that population_history :: Vector{typeof(n₀)}.  Unless a specified statistic! function is given.\nThe parameter variable par is passed through all functions (execute!,rates!,statistics!), thereby affording the user additional flexibility.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.saveonestep!-Tuple{Any, Any, Dict{<:Any, <:Number}, Any}","page":"Public API","title":"DenseGillespieAlgorithm.saveonestep!","text":"    saveonestep!(pop_hist,index,ps,par)\n\nSave one step of the simulation. Generic method if no explicit statistic! function is given.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.stop!-Union{Tuple{F1}, Tuple{Any, Any, Any, Any, F1}} where F1","page":"Public API","title":"DenseGillespieAlgorithm.stop!","text":"    stop!(pop_hist,index,n0,par,stat!)\n\nFill the remaining population history with the (statistic of) the current population state if the evolution came to a halt.\n\n\n\n\n\n","category":"method"},{"location":"index.html#DenseGillespieAlgorithm.sumsumdict-Tuple{Any}","page":"Public API","title":"DenseGillespieAlgorithm.sumsumdict","text":"sumsumdict(D::Dict{String,Vector})\n\nCalculate the sum of the sums of the vectors that are the values of a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"DGAPackage.html#The-DenseGillespieAlgorithm","page":"Home","title":"The DenseGillespieAlgorithm","text":"","category":"section"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"This package implements a version of the Gillespies algorithm that performs exact stochastic simulations for dense problems. The Gillespie algorithm[Gillespie76], introduced by Daniel Gillespie in 1976, is a fundamental tool for simulating the time evolution of systems with discrete, stochastic events, particularly in contexts like biochemical reactions and population dynamics. Its applications are particularly prevalent in contexts such as biochemical reactions and population dynamics. The Gillespie Algorithm is employed to simulate the behaviour of systems wherein reactions or events occur at random intervals. The algorithm generates a sequence of events and their timings by first calculating the rates at which different events or reactions occur. Subsequently, the time until the next event is determined based on these rates, and the type of event that occurs next is selected according to its probability. In the final step, the system state is updated based on the event, and the process is repeated.","category":"page"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"[Gillespie76]: D.T. Gillespie. A general method for numerically simulating the stochastic time evolution of coupled chemical reactions. Journal of Computational Physics, 22(4):403-434, 1976","category":"page"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"The Gillespie algorithm is a highly renowned and widely utilised technique across diverse communities and ecosystems. A particularly efficient, flexible and comprehensive implementation can be found in the JumpProcess.jl package within the SciML ecosystem. We strongly recommend the use of this framework wherever feasible. ","category":"page"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"However, the majority of implementations of the Gillespie algorithm require prior knowledge of all potential types and all reactions between these types before the reaction commences. A classic illustration of this is the SIR model (see Examples). The objective of our implementation in this package is to eliminate this restriction and permit the consideration of both high-dimensional systems, where the precise interactions between every conceivable combination are theoretically possible but practically infeasible, and additionally, systems where the trait space is uncountable, such as the real line. In both cases, the number of distinct traits that are present at any given time is finite, given that the population size is limited. However, new types emerge during the course of the simulation, and the interactions between these types are determined by their specific characteristics. ","category":"page"},{"location":"DGAPackage.html#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"Pages = [\"manual.md\",\"examples.md\",\"perform.md\",\"index.md\"]","category":"page"},{"location":"DGAPackage.html#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"DGAPackage.html","page":"Home","title":"Home","text":"Modules = [DenseGillespieAlgorithm]\nOrder   = [:constant, :type, :function, :macro]","category":"page"}]
}
