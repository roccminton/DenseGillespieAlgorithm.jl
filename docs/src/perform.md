# Performance tips

One of the key benefits of the Gillespie algorithm is its ability to trace a single, precise stochastic trajectory. Nevertheless, in order to achieve this for each individual event, the rates must be calculated and re-calculated whenever there is a change in the population configuration. This makes the algorithm computationally demanding. There are numerous modifications that can be made in order to enhance performance, such as ``\tau``-leaping[^Gillespie01]. However, in this section, our objective is to maintain the precision of the stochastic simulation and to identify potential bottlenecks and strategies for optimising the performance of the simulation in its current form.

[^Gillespie01]: D.T. Gillespie. Approximate accelerated stochastic simulation of chemically reacting systems. _Journal of Chemical Physics_, 115(4):1716-1733, 2001

## Julia performance tips and benchmarking
The Julia documentation contains a comprehensive and invaluable array of [performance tips](https://docs.julialang.org/en/v1/manual/performance-tips/). Should you encounter any unexpected delays in your simulations, we advise you to consult these tips. It is likely that you will find a solution to the problem by following the guidance provided. Additionally, we recommend that you review the [workflow tips](https://docs.julialang.org/en/v1/manual/workflow-tips/) and the [style guide](https://docs.julialang.org/en/v1/manual/style-guide/). These resources assist in enhancing the efficiency, readability, and overall quality of your code. In particular, we recommend these chapters of the documentation for researchers who are new to Julia.
To assess the efficacy of the functions within your model, Julia offers an exemplary benchmarking package called [BenchmarkingTools.jl](https://juliaci.github.io/BenchmarkTools.jl/stable/). This enables the comparison of different versions of your code, facilitating the selection of the most optimal version.

## Natural bottleneck in Gillespies Algorithm
It should be noted that both the `rates!` and `execute!` functions will be called a considerable number of times during the course of the simulation. To illustrate, consider a species with a reproduction rate of ``1`` within a population of ``1\,000`` individuals over a time horizon of ``1\,000`` generations. In this scenario, the `rates!` and `execute!` functions will be called approximately one million times solely for reproduction events. Consequently, it is crucial to implement these functions with optimal performance. Every millisecond gained, every byte saved can significantly impact the runtime and efficiency of the program.

## Reuse memory space
Avoid to recreate containers such as arrays or dictionaries, particularly within the `execute!` and `rates!` function. Reuse of these containers is preferable to the allocation of new memory space with each iteration. The accumulation of data over the course of a simulation can lead to a reduction in performance.

## Recalculate vs. update
In certain scenarios, it is preferable to recalculate data from the current population state rather than update the data after every event, depending on the model and model parameter in question. For other models the opposite is may be true. In cases where there is uncertainty about the optimal implementation strategy, it is recommended to implement both versions and evaluate their performance using the [BenchmarkingTools.jl](https://juliaci.github.io/BenchmarkTools.jl/stable/) package. This is the case for the event rates, which should be recalculated or updated depending on the circumstances and for the additional statistics that may be saved. However, it should be noted that the `rates!` function is usually called much more frequently than the `statistics!` function. The statistics are saved at regular intervals, as specified by the time horizon input to the algorithm, whereas the rates function is called after each event.

## Keep calm
The Gillespie Algorithm is a computationally intensive algorithm due to its exact nature. Following the implementation of complex networks on a high-dimensional trait space, the execution may require a significant amount of time. It is recommended to test the algorithm on a smaller scale, benchmark and adapt functions regularly, and only to be concerned if the time required to produce the simulation is unexpectedly long or if a disproportionate amount of memory is allocated.
Otherwise, grab a coffee and check out the [progress meter](https://github.com/timholy/ProgressMeter.jl) to see how things are going with the simulation.